<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FAIT-MaiN</title>
  
  
  <link href="https://magic-nikos.github.io/atom.xml" rel="self"/>
  
  <link href="https://magic-nikos.github.io/"/>
  <updated>2024-03-01T14:29:54.800Z</updated>
  <id>https://magic-nikos.github.io/</id>
  
  <author>
    <name>Chat GPT 3.5</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Projets pratiques</title>
    <link href="https://magic-nikos.github.io/2024/03/01/Projets-pratiques/"/>
    <id>https://magic-nikos.github.io/2024/03/01/Projets-pratiques/</id>
    <published>2024-03-01T14:29:35.000Z</published>
    <updated>2024-03-01T14:29:54.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Debutants-en-OpenCV-Projets-pratiques"><a href="#Debutants-en-OpenCV-Projets-pratiques" class="headerlink" title="Débutants en OpenCV : Projets pratiques"></a>Débutants en OpenCV : Projets pratiques</h1><p>Bienvenue dans cet article dédié aux projets pratiques en OpenCV, un outil puissant pour le traitement d’images et de vidéos. Dans cette publication, nous allons explorer différentes applications pratiques que vous pouvez réaliser en utilisant OpenCV. Que vous soyez un débutant ou un amateur d’informatique visuelle, ces projets vous aideront à mettre en pratique vos compétences en OpenCV.</p><h2 id="Projet-1-Detection-de-visages"><a href="#Projet-1-Detection-de-visages" class="headerlink" title="Projet 1 : Détection de visages"></a>Projet 1 : Détection de visages</h2><p>La première application pratique que nous allons aborder est la détection de visages. OpenCV propose des fonctionnalités de détection d’objets prédéfinis, ce qui facilite la détection de visages dans une image ou une vidéo. Voici un exemple de code en Python pour détecter les visages à l’aide de CascadeClassifier :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Chargement du cascade classifier pré-entraîné</span></span><br><span class="line">face_cascade = cv2.CascadeClassifier(<span class="string">&#x27;haarcascade_frontalface_default.xml&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Lecture de l&#x27;image d&#x27;entrée</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;face.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Conversion en niveaux de gris</span></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Détection des visages</span></span><br><span class="line">faces = face_cascade.detectMultiScale(gray, scaleFactor=<span class="number">1.1</span>, minNeighbors=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dessiner des rectangles autour des visages détectés</span></span><br><span class="line"><span class="keyword">for</span> (x, y, w, h) <span class="keyword">in</span> faces:</span><br><span class="line">    cv2.rectangle(img, (x, y), (x+w, y+h), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Affichage de l&#x27;image avec les visages détectés</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;Detected Faces&#x27;</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="Projet-2-Reconnaissance-d’objets"><a href="#Projet-2-Reconnaissance-d’objets" class="headerlink" title="Projet 2 : Reconnaissance d’objets"></a>Projet 2 : Reconnaissance d’objets</h2><p>Dans ce deuxième projet, nous allons aborder la reconnaissance d’objets à l’aide d’OpenCV et de modèles pré-entrainés tels que YOLO (You Only Look Once). Voici un exemple pour détecter des objets dans une vidéo :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Chargement du modèle YOLO</span></span><br><span class="line">net = cv2.dnn.readNet(<span class="string">&#x27;yolov3.weights&#x27;</span>, <span class="string">&#x27;yolov3.cfg&#x27;</span>)</span><br><span class="line">classes = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;coco.names&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    classes = f.read().splitlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Lecture de la vidéo d&#x27;entrée</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="string">&#x27;object_detection.mp4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    success, img = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> success:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    blob = cv2.dnn.blobFromImage(img, <span class="number">1</span>/<span class="number">255</span>, (<span class="number">416</span>, <span class="number">416</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="literal">True</span>, crop=<span class="literal">False</span>)</span><br><span class="line">    net.setInput(blob)</span><br><span class="line">    output_layers_names = net.getUnconnectedOutLayersNames()</span><br><span class="line">    layer_outputs = net.forward(output_layers_names)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Afficher les détections des objets</span></span><br><span class="line">    <span class="keyword">for</span> output <span class="keyword">in</span> layer_outputs:</span><br><span class="line">        <span class="keyword">for</span> detection <span class="keyword">in</span> output:</span><br><span class="line">            <span class="comment"># ...</span></span><br><span class="line">    </span><br><span class="line">    cv2.imshow(<span class="string">&#x27;Object Detection&#x27;</span>, img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Les projets pratiques en OpenCV offrent une multitude d’applications possibles, de la détection de visages à la reconnaissance d’objets en passant par la segmentation d’images. En mettant en pratique ces projets, vous allez acquérir une expérience précieuse dans le domaine du traitement d’images et de vidéos. N’hésitez pas à explorer davantage pour découvrir les multiples utilisations fascinantes des capacités d’OpenCV.</p><p>N’oubliez pas que la pratique est essentielle pour maîtriser OpenCV. Alors lancez-vous dans ces projets pratiques et explorez les possibilités infinies qu’OpenCV a à offrir !</p><p>Pour en savoir plus sur OpenCV et ses applications, consultez <a href="https://opencv.org/">le site officiel d’OpenCV</a>. Profitez de votre voyage dans le monde captivant du traitement d’images ! 🌟</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Debutants-en-OpenCV-Projets-pratiques&quot;&gt;&lt;a href=&quot;#Debutants-en-OpenCV-Projets-pratiques&quot; class=&quot;headerlink&quot; title=&quot;Débutants en OpenC</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://magic-nikos.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="https://magic-nikos.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://magic-nikos.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Applications de réalité augmentée</title>
    <link href="https://magic-nikos.github.io/2024/03/01/Applications-de-realite-augmentee/"/>
    <id>https://magic-nikos.github.io/2024/03/01/Applications-de-realite-augmentee/</id>
    <published>2024-03-01T14:29:18.000Z</published>
    <updated>2024-03-01T14:29:33.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Debutants-en-OpenCV-Applications-de-realite-augmentee"><a href="#Debutants-en-OpenCV-Applications-de-realite-augmentee" class="headerlink" title="Débutants en OpenCV : Applications de réalité augmentée"></a>Débutants en OpenCV : Applications de réalité augmentée</h1><hr><p>La réalité augmentée est une technologie fascinante qui mélange le monde réel avec des éléments virtuels en temps réel. Avec l’utilisation d’OpenCV, une bibliothèque open source de vision par ordinateur, il est possible de créer des applications de réalité augmentée captivantes. Dans cet article, nous allons explorer les bases de la réalité augmentée et comment vous pouvez commencer à créer vos propres applications.</p><h2 id="Qu’est-ce-que-la-realite-augmentee"><a href="#Qu’est-ce-que-la-realite-augmentee" class="headerlink" title="Qu’est-ce que la réalité augmentée ?"></a>Qu’est-ce que la réalité augmentée ?</h2><p>La réalité augmentée est la superposition d’éléments virtuels tels que des images, des vidéos ou des modèles 3D sur le monde réel. Cette technologie donne l’impression que ces éléments virtuels font partie de l’environnement réel observé par une caméra. Les applications de réalité augmentée sont utilisées dans divers domaines tels que les jeux, la publicité, l’éducation et la formation.</p><h2 id="Comment-fonctionne-la-realite-augmentee-avec-OpenCV"><a href="#Comment-fonctionne-la-realite-augmentee-avec-OpenCV" class="headerlink" title="Comment fonctionne la réalité augmentée avec OpenCV ?"></a>Comment fonctionne la réalité augmentée avec OpenCV ?</h2><p>Pour créer une application de réalité augmentée, vous avez besoin de plusieurs éléments essentiels : </p><ul><li>Une source d’images du monde réel, généralement une caméra.</li><li>Des marqueurs ou des repères visuels pour détecter et suivre les objets dans l’environnement.</li><li>Des modèles 3D ou des éléments virtuels à superposer sur les marqueurs détectés.</li></ul><p>OpenCV offre des fonctionnalités puissantes pour la détection d’objets, le suivi de la pose et le rendu des éléments virtuels. En utilisant ces fonctionnalités, vous pouvez créer des expériences immersives de réalité augmentée.</p><h2 id="Exemple-d’application-de-realite-augmentee-avec-OpenCV"><a href="#Exemple-d’application-de-realite-augmentee-avec-OpenCV" class="headerlink" title="Exemple d’application de réalité augmentée avec OpenCV"></a>Exemple d’application de réalité augmentée avec OpenCV</h2><p>Imaginons que vous souhaitiez créer une application de réalité augmentée qui superpose un emoji souriant sur le visage d’une personne détectée par la caméra. Voici les étapes clés pour réaliser cela :</p><ol><li>Capturer une image de la caméra en temps réel.</li><li>Détecter le visage dans l’image en utilisant des techniques de vision par ordinateur.</li><li>Superposer l’emoji souriant sur le visage détecté.</li><li>Afficher l’image résultante avec l’emoji augmenté.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Exemple de code pour superposer un emoji sur un visage</span></span><br><span class="line"><span class="comment"># (Code Python utilisant OpenCV)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Capturer l&#x27;image de la caméra</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">ret, frame = cap.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Détecter le visage dans l&#x27;image</span></span><br><span class="line"><span class="comment"># (Code de détection du visage va ici)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Superposer l&#x27;emoji souriant sur le visage</span></span><br><span class="line"><span class="comment"># (Code de superposition de l&#x27;emoji va ici)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Afficher l&#x27;image avec l&#x27;emoji augmenté</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;Augmented Reality&#x27;</span>, frame)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="Les-applications-potentielles-de-la-realite-augmentee"><a href="#Les-applications-potentielles-de-la-realite-augmentee" class="headerlink" title="Les applications potentielles de la réalité augmentée"></a>Les applications potentielles de la réalité augmentée</h2><p>Les applications de la réalité augmentée sont infinies. Elles peuvent inclure des jeux interactifs basés sur la géolocalisation, des outils de visualisation pour l’architecture et le design, des applications éducatives immersives, des expériences de shopping virtuel, et bien plus encore. La réalité augmentée ouvre de nouvelles possibilités créatives et pratiques dans de nombreux domaines.</p><hr><p>En conclusion, la réalité augmentée avec OpenCV offre un monde d’opportunités pour créer des expériences visuelles uniques et engageantes. En combinant la puissance de la vision par ordinateur avec la magie de la superposition d’éléments virtuels sur le monde réel, vous pouvez explorer de nouvelles frontières de l’interaction homme-machine. Alors, lancez-vous et commencez à explorer les possibilités infinies des applications de réalité augmentée avec OpenCV !</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Debutants-en-OpenCV-Applications-de-realite-augmentee&quot;&gt;&lt;a href=&quot;#Debutants-en-OpenCV-Applications-de-realite-augmentee&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://magic-nikos.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="https://magic-nikos.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://magic-nikos.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Traitement d&#39;images satellite</title>
    <link href="https://magic-nikos.github.io/2024/03/01/Traitement-d-images-satellite/"/>
    <id>https://magic-nikos.github.io/2024/03/01/Traitement-d-images-satellite/</id>
    <published>2024-03-01T14:29:02.000Z</published>
    <updated>2024-03-01T14:29:16.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Guide-de-Traitement-d’images-satellite-avec-OpenCV"><a href="#Guide-de-Traitement-d’images-satellite-avec-OpenCV" class="headerlink" title="Guide de Traitement d’images satellite avec OpenCV"></a>Guide de Traitement d’images satellite avec OpenCV</h1><p>Bienvenue dans ce guide qui vous initiera au traitement d’images satellite en utilisant OpenCV. Dans cet article, nous allons explorer les bases de ce sujet passionnant, en abordant les concepts essentiels et en fournissant des exemples concrets pour une meilleure compréhension.</p><h2 id="Introduction-a-l’imagerie-satellite"><a href="#Introduction-a-l’imagerie-satellite" class="headerlink" title="Introduction à l’imagerie satellite"></a>Introduction à l’imagerie satellite</h2><p>L’imagerie satellite consiste à capturer des images de la Terre depuis des satellites en orbite. Ces images sont riches en informations et peuvent être utilisées dans de nombreux domaines tels que la cartographie, l’agriculture, la surveillance environnementale, etc. Le traitement d’images satellite vise à extraire des informations utiles à partir de ces images en utilisant des techniques informatiques.</p><h2 id="Installation-d’OpenCV"><a href="#Installation-d’OpenCV" class="headerlink" title="Installation d’OpenCV"></a>Installation d’OpenCV</h2><p>Avant de commencer, assurez-vous d’avoir OpenCV installé sur votre système. Vous pouvez le faire en exécutant la commande suivante :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure><h2 id="Chargement-de-l’image-satellite"><a href="#Chargement-de-l’image-satellite" class="headerlink" title="Chargement de l’image satellite"></a>Chargement de l’image satellite</h2><p>La première étape consiste à charger une image satellite à l’aide de OpenCV. Voici un exemple de code pour charger une image et l’afficher :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">image = cv2.imread(<span class="string">&#x27;satellite_image.jpg&#x27;</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;Image satellite&#x27;</span>, image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="Pretraitement-de-l’image"><a href="#Pretraitement-de-l’image" class="headerlink" title="Prétraitement de l’image"></a>Prétraitement de l’image</h2><p>Avant d’appliquer des techniques de traitement d’images, il est souvent nécessaire de prétraiter l’image. Cela peut inclure des opérations telles que la normalisation, le filtrage et la correction de distorsion. Voici un exemple de filtre de flou appliqué sur l’image :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blurred_image = cv2.GaussianBlur(image, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="Detection-des-elements-d’interet"><a href="#Detection-des-elements-d’interet" class="headerlink" title="Détection des éléments d’intérêt"></a>Détection des éléments d’intérêt</h2><p>Une des tâches courantes en traitement d’images satellite est la détection des éléments d’intérêt tels que les bâtiments, les routes ou les cours d’eau. Cela peut être réalisé en utilisant des algorithmes de détection d’objets ou de segmentation. Voici un exemple simple de détection de contours :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gray_image = cv2.cvtColor(blurred_image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">edges = cv2.Canny(gray_image, <span class="number">50</span>, <span class="number">150</span>)</span><br></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Le traitement d’images satellite avec OpenCV ouvre un large éventail d’applications potentielles, allant de la surveillance urbaine à la gestion des catastrophes naturelles. En acquérant des compétences dans ce domaine, vous serez en mesure d’analyser et d’extraire des informations précieuses à partir d’images satellite pour prendre des décisions éclairées dans divers domaines.</p><p>N’hésitez pas à explorer davantage les fonctionnalités d’OpenCV et à expérimenter avec différents algorithmes pour approfondir vos connaissances en traitement d’images satellite. Bonne exploration !</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Guide-de-Traitement-d’images-satellite-avec-OpenCV&quot;&gt;&lt;a href=&quot;#Guide-de-Traitement-d’images-satellite-avec-OpenCV&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://magic-nikos.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="https://magic-nikos.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://magic-nikos.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Traitement d&#39;images médicales</title>
    <link href="https://magic-nikos.github.io/2024/03/01/Traitement-d-images-medicales/"/>
    <id>https://magic-nikos.github.io/2024/03/01/Traitement-d-images-medicales/</id>
    <published>2024-03-01T14:28:46.000Z</published>
    <updated>2024-03-01T14:28:59.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Traitement-d’images-medicales-avec-OpenCV"><a href="#Traitement-d’images-medicales-avec-OpenCV" class="headerlink" title="Traitement d’images médicales avec OpenCV"></a>Traitement d’images médicales avec OpenCV</h1><p>Le traitement d’images médicales est un domaine fascinant de l’informatique médicale qui utilise des techniques d’imagerie numérique pour aider les professionnels de la santé à diagnostiquer et traiter les patients. Dans cet article, nous allons explorer comment OpenCV, une bibliothèque open source populaire pour le traitement d’images, peut être utilisée dans le contexte spécifique du domaine médical.</p><h2 id="Introduction-a-l’OpenCV-et-aux-images-medicales"><a href="#Introduction-a-l’OpenCV-et-aux-images-medicales" class="headerlink" title="Introduction à l’OpenCV et aux images médicales"></a>Introduction à l’OpenCV et aux images médicales</h2><p>OpenCV est une bibliothèque open source largement utilisée pour le traitement d’images. Elle offre une multitude de fonctions pour manipuler et analyser des images, ce qui la rend particulièrement utile dans le domaine médical. Les images médicales, telles que les radiographies, les IRM et les scanners, peuvent être traitées pour extraire des informations précieuses qui aident les professionnels de la santé dans leur diagnostic et leur traitement.</p><h2 id="Chargement-et-affichage-d’images-medicales"><a href="#Chargement-et-affichage-d’images-medicales" class="headerlink" title="Chargement et affichage d’images médicales"></a>Chargement et affichage d’images médicales</h2><p>Avant de commencer tout traitement sur une image médicale, il est essentiel de la charger correctement dans notre application. OpenCV fournit des fonctions simples pour charger et afficher des images, que ce soit en niveaux de gris ou en couleur. Par exemple, pour charger une image en niveaux de gris en utilisant OpenCV en Python, on peut utiliser le code suivant :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">image = cv2.imread(<span class="string">&#x27;medical_image.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;Medical Image&#x27;</span>, image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="Pretraitement-des-images-medicales"><a href="#Pretraitement-des-images-medicales" class="headerlink" title="Prétraitement des images médicales"></a>Prétraitement des images médicales</h2><p>Avant d’appliquer des algorithmes plus avancés sur les images médicales, il est courant de prétraiter ces images pour améliorer leur qualité et faciliter l’analyse ultérieure. Le prétraitement peut inclure des opérations telles que la réduction du bruit, la normalisation de l’histogramme et la détection des bords. OpenCV offre des fonctions pour effectuer ces opérations. Par exemple, pour réduire le bruit dans une image médicale, on peut utiliser un filtre de lissage comme le filtre gaussien :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image_smoothed = cv2.GaussianBlur(image, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="Segmentation-d’images-medicales"><a href="#Segmentation-d’images-medicales" class="headerlink" title="Segmentation d’images médicales"></a>Segmentation d’images médicales</h2><p>La segmentation d’images médicales consiste à diviser une image en régions ou objets d’intérêt. Cela peut être utile pour détecter des tissus spécifiques ou des anomalies dans une image médicale. OpenCV propose des techniques de segmentation avancées, telles que la segmentation par seuillage ou par regroupement de pixels. Par exemple, pour segmenter une image en utilisant un seuil, on peut utiliser la fonction <code>threshold</code> :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret, thresholded_image = cv2.threshold(image, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Le traitement d’images médicales avec OpenCV offre un potentiel énorme pour améliorer les soins de santé en permettant une analyse rapide et précise des images médicales. En combinant les fonctionnalités avancées d’OpenCV avec des techniques d’apprentissage automatique, il est possible de créer des systèmes d’aide au diagnostic puissants et efficaces. Ce domaine en pleine croissance ouvre la voie à de nombreuses applications passionnantes dans le domaine médical.</p><p>Dans cet article, nous avons effleuré quelques-unes des techniques de base utilisées dans le traitement d’images médicales avec OpenCV. En explorant davantage la bibliothèque et en expérimentant avec des jeux de données médicaux, vous pourrez découvrir tout le potentiel de cette combinaison pour l’analyse et la visualisation d’images en médecine.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Traitement-d’images-medicales-avec-OpenCV&quot;&gt;&lt;a href=&quot;#Traitement-d’images-medicales-avec-OpenCV&quot; class=&quot;headerlink&quot; title=&quot;Traitement</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://magic-nikos.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="https://magic-nikos.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://magic-nikos.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Caméra stéréo</title>
    <link href="https://magic-nikos.github.io/2024/03/01/Camera-stereo/"/>
    <id>https://magic-nikos.github.io/2024/03/01/Camera-stereo/</id>
    <published>2024-03-01T14:28:33.000Z</published>
    <updated>2024-03-01T14:28:43.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Decouvrir-la-magie-de-la-Camera-Stereo-avec-OpenCV"><a href="#Decouvrir-la-magie-de-la-Camera-Stereo-avec-OpenCV" class="headerlink" title="Découvrir la magie de la Caméra Stéréo avec OpenCV"></a>Découvrir la magie de la Caméra Stéréo avec OpenCV</h1><p>La caméra stéréo est une technologie fascinante utilisée en vision par ordinateur pour capturer des images en 3D et est largement implémentée dans des applications telles que la réalité augmentée, la reconstruction 3D, et la robotique. Avec OpenCV, une bibliothèque très populaire en vision par ordinateur, il est possible d’exploiter pleinement le potentiel des caméras stéréo. </p><h2 id="Qu’est-ce-qu’une-Camera-Stereo"><a href="#Qu’est-ce-qu’une-Camera-Stereo" class="headerlink" title="Qu’est-ce qu’une Caméra Stéréo ?"></a>Qu’est-ce qu’une Caméra Stéréo ?</h2><p>Une caméra stéréo se compose de deux caméras placées à une distance fixe l’une de l’autre, simulant la vision humaine binoculaire. Ces deux caméras capturent des images d’une scène depuis des points de vue légèrement différents, ce qui permet de calculer la profondeur et la distance des objets à l’aide de la vision stéréoscopique.</p><h2 id="Comment-fonctionne-la-Vision-Stereo-avec-OpenCV"><a href="#Comment-fonctionne-la-Vision-Stereo-avec-OpenCV" class="headerlink" title="Comment fonctionne la Vision Stéréo avec OpenCV ?"></a>Comment fonctionne la Vision Stéréo avec OpenCV ?</h2><p>OpenCV propose des fonctions et des méthodes spécifiques pour traiter les images capturées par des caméras stéréo. Voici un exemple de code simple pour charger des images provenant de deux caméras stéréo et calculer la carte de profondeur :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Charger les images pour la vision stéréo</span></span><br><span class="line">img_left = cv2.imread(<span class="string">&#x27;image_gauche.jpg&#x27;</span>)</span><br><span class="line">img_right = cv2.imread(<span class="string">&#x27;image_droite.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Définir les paramètres de la vision stéréo</span></span><br><span class="line">stereo = cv2.StereoBM_create(numDisparities=<span class="number">16</span>, blockSize=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculer la carte de profondeur</span></span><br><span class="line">disparity = stereo.compute(img_left, img_right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Afficher la carte de profondeur</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;Disparity Map&#x27;</span>, disparity)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>Ce code simple démontre la puissance de la vision stéréo avec OpenCV pour calculer une carte de profondeur à partir d’images stéréo.</p><h2 id="Utilisations-et-Applications-de-la-Camera-Stereo"><a href="#Utilisations-et-Applications-de-la-Camera-Stereo" class="headerlink" title="Utilisations et Applications de la Caméra Stéréo"></a>Utilisations et Applications de la Caméra Stéréo</h2><p>La caméra stéréo offre de nombreuses applications potentielles dans divers domaines. Certaines utilisations courantes incluent la reconstruction 3D de scènes, la détection d’obstacles pour la navigation des robots, et même la réalité augmentée pour superposer des éléments virtuels sur un environnement réel de manière précise.</p><p>En conclusion, la caméra stéréo associée à OpenCV ouvre un monde de possibilités en vision par ordinateur. En comprenant les concepts de base et en explorant les fonctionnalités offertes par cette combinaison, il devient possible de créer des applications innovantes et interactives basées sur la vision tridimensionnelle.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Decouvrir-la-magie-de-la-Camera-Stereo-avec-OpenCV&quot;&gt;&lt;a href=&quot;#Decouvrir-la-magie-de-la-Camera-Stereo-avec-OpenCV&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://magic-nikos.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="https://magic-nikos.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://magic-nikos.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Analyse de mouvement</title>
    <link href="https://magic-nikos.github.io/2024/03/01/Analyse-de-mouvement/"/>
    <id>https://magic-nikos.github.io/2024/03/01/Analyse-de-mouvement/</id>
    <published>2024-03-01T14:28:18.000Z</published>
    <updated>2024-03-01T14:28:31.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Analyse-de-mouvement-avec-OpenCV"><a href="#Analyse-de-mouvement-avec-OpenCV" class="headerlink" title="Analyse de mouvement avec OpenCV"></a>Analyse de mouvement avec OpenCV</h1><p>L’analyse de mouvement est une technique clé en vision par ordinateur qui permet de détecter et suivre les mouvements dans des séquences d’images. Dans cet article, nous allons explorer comment mettre en œuvre l’analyse de mouvement à l’aide de la bibliothèque OpenCV, un ensemble d’outils open source très populaire pour le traitement d’images et de vidéos.</p><h2 id="Introduction-a-l’Analyse-de-Mouvement"><a href="#Introduction-a-l’Analyse-de-Mouvement" class="headerlink" title="Introduction à l’Analyse de Mouvement"></a>Introduction à l’Analyse de Mouvement</h2><p>L’analyse de mouvement consiste à détecter les changements d’état dans une séquence d’images. Cela peut être utilisé pour suivre des objets en mouvement, pour la surveillance vidéo, l’analyse du comportement, etc.</p><h2 id="Detection-de-mouvement-avec-OpenCV"><a href="#Detection-de-mouvement-avec-OpenCV" class="headerlink" title="Détection de mouvement avec OpenCV"></a>Détection de mouvement avec OpenCV</h2><p>Pour détecter le mouvement avec OpenCV, nous allons utiliser la méthode de soustraction d’arrière-plan. Cette méthode consiste à soustraire l’image actuelle à l’image précédente pour détecter les régions où des changements significatifs ont eu lieu.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="string">&#x27;video.mp4&#x27;</span>)</span><br><span class="line">ret, frame1 = cap.read()</span><br><span class="line">ret, frame2 = cap.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    diff = cv2.absdiff(frame1, frame2)</span><br><span class="line">    gray = cv2.cvtColor(diff, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    blur = cv2.GaussianBlur(gray, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line">    _, thresh = cv2.threshold(blur, <span class="number">20</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">    </span><br><span class="line">    cv2.imshow(<span class="string">&#x27;Motion Detection&#x27;</span>, thresh)</span><br><span class="line">    </span><br><span class="line">    frame1 = frame2</span><br><span class="line">    ret, frame2 = cap.read()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>Dans cet exemple, nous capturons une vidéo, calculons la différence entre deux images consécutives, appliquons un flou gaussien et définissons un seuil pour détecter les zones de mouvement.</p><h2 id="Suivi-de-mouvement"><a href="#Suivi-de-mouvement" class="headerlink" title="Suivi de mouvement"></a>Suivi de mouvement</h2><p>Pour suivre le mouvement d’un objet dans une vidéo, nous pouvons utiliser des techniques de suivi d’objets disponibles dans OpenCV telles que le suivi de contour ou le suivi optique de flux. Ces méthodes nous permettent de suivre la trajectoire des objets en mouvement.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>L’analyse de mouvement avec OpenCV offre une multitude d’applications pratiques, allant de la surveillance vidéo à la réalité augmentée en passant par les interfaces homme-machine. En maîtrisant les techniques présentées dans cet article, vous serez en mesure de développer des systèmes intelligents capables de comprendre et d’interagir avec l’environnement en mouvement.</p><p>N’hésitez pas à explorer davantage les fonctionnalités d’OpenCV pour repousser les limites de l’analyse de mouvement dans vos projets futurs.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Analyse-de-mouvement-avec-OpenCV&quot;&gt;&lt;a href=&quot;#Analyse-de-mouvement-avec-OpenCV&quot; class=&quot;headerlink&quot; title=&quot;Analyse de mouvement avec Op</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://magic-nikos.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="https://magic-nikos.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://magic-nikos.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Reconnaissance faciale</title>
    <link href="https://magic-nikos.github.io/2024/03/01/Reconnaissance-faciale/"/>
    <id>https://magic-nikos.github.io/2024/03/01/Reconnaissance-faciale/</id>
    <published>2024-03-01T14:27:52.000Z</published>
    <updated>2024-03-01T14:28:15.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reconnaissance-faciale-avec-OpenCV"><a href="#Reconnaissance-faciale-avec-OpenCV" class="headerlink" title="Reconnaissance faciale avec OpenCV"></a>Reconnaissance faciale avec OpenCV</h1><p>La reconnaissance faciale est une application fascinante de l’intelligence artificielle qui consiste à identifier ou vérifier des individus en analysant des images de leurs traits du visage. Dans cet article, nous allons vous guider à travers les étapes pour mettre en place un système de reconnaissance faciale en utilisant OpenCV, une bibliothèque open-source populaire de vision par ordinateur. </p><h3 id="Introduction-a-la-reconnaissance-faciale"><a href="#Introduction-a-la-reconnaissance-faciale" class="headerlink" title="Introduction à la reconnaissance faciale"></a>Introduction à la reconnaissance faciale</h3><p>La reconnaissance faciale repose sur la détection et la comparaison des caractéristiques du visage d’une personne. OpenCV simplifie ce processus en fournissant des outils prêts à l’emploi pour la capture d’images, la détection de visages, et l’extraction de caractéristiques.</p><h3 id="Installation-d’OpenCV"><a href="#Installation-d’OpenCV" class="headerlink" title="Installation d’OpenCV"></a>Installation d’OpenCV</h3><p>Avant de commencer, assurez-vous d’avoir OpenCV installé sur votre système. Voici comment vous pouvez procéder avec Python :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python </span><br></pre></td></tr></table></figure><h3 id="Detection-de-visages"><a href="#Detection-de-visages" class="headerlink" title="Détection de visages"></a>Détection de visages</h3><p>Pour commencer, importez les modules nécessaires et chargez un modèle de détection de visages pré-entraîné. Ensuite, vous pouvez capturer une image et détecter les visages présents :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Charger le modèle de détection de visages</span></span><br><span class="line">face_cascade = cv2.CascadeClassifier(<span class="string">&#x27;haarcascade_frontalface_default.xml&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Capturer l&#x27;image</span></span><br><span class="line">image = cv2.imread(<span class="string">&#x27;sample_image.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convertir l&#x27;image en niveaux de gris</span></span><br><span class="line">gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Détecter les visages</span></span><br><span class="line">faces = face_cascade.detectMultiScale(gray_image, scaleFactor=<span class="number">1.1</span>, minNeighbors=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dessiner un rectangle autour des visages détectés</span></span><br><span class="line"><span class="keyword">for</span> (x, y, w, h) <span class="keyword">in</span> faces:</span><br><span class="line">    cv2.rectangle(image, (x, y), (x+w, y+h), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Afficher l&#x27;image avec les visages détectés</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;Detected Faces&#x27;</span>, image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="Reconnaissance-faciale"><a href="#Reconnaissance-faciale" class="headerlink" title="Reconnaissance faciale"></a>Reconnaissance faciale</h3><p>Pour la reconnaissance faciale, vous pouvez utiliser des techniques telles que la comparaison de caractéristiques faciales ou la création d’emplacements de visages. Ces techniques avancées peuvent être mises en œuvre en utilisant des algorithmes de machine learning.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>La reconnaissance faciale offre des applications infinies, allant de la sécurité biométrique à l’organisation d’événements. En combinant la puissance d’OpenCV avec des algorithmes de pointe, il est possible de développer des systèmes de reconnaissance faciale robustes et efficaces.</p><p>Dans cet article, nous avons exploré les concepts fondamentaux de la reconnaissance faciale en utilisant OpenCV. En expérimentant avec les techniques de détection et de comparaison de visages, vous êtes maintenant prêt à plonger plus profondément dans ce domaine fascinant de l’intelligence artificielle.</p><p>Pour en savoir plus sur les applications passionnantes de la reconnaissance faciale, restez connecté à notre blog éducatif !</p><hr><p><em>Vous avez maintenant toutes les connaissances de base pour commencer à explorer la reconnaissance faciale avec OpenCV. N’hésitez pas à expérimenter davantage et à découvrir les nombreuses façons innovantes dont cette technologie peut être utilisée.</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Reconnaissance-faciale-avec-OpenCV&quot;&gt;&lt;a href=&quot;#Reconnaissance-faciale-avec-OpenCV&quot; class=&quot;headerlink&quot; title=&quot;Reconnaissance faciale a</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://magic-nikos.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="https://magic-nikos.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://magic-nikos.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Détection de visage</title>
    <link href="https://magic-nikos.github.io/2024/03/01/Detection-de-visage/"/>
    <id>https://magic-nikos.github.io/2024/03/01/Detection-de-visage/</id>
    <published>2024-03-01T14:27:31.000Z</published>
    <updated>2024-03-01T14:27:49.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Dans le domaine de la vision par ordinateur, la détection de visages est l’une des tâches les plus courantes et fascinantes. C’est une application populaire d’OpenCV, une bibliothèque de traitement d’images largement utilisée. Dans cet article, nous allons explorer les bases de la détection de visage en utilisant OpenCV. Vous apprendrez comment détecter des visages dans des images et des vidéos, ainsi que les concepts clés derrière cette technologie.</p><h1 id="Prerequis"><a href="#Prerequis" class="headerlink" title="Prérequis"></a>Prérequis</h1><p>Avant de commencer, assurez-vous d’avoir OpenCV installé sur votre machine. Vous pouvez l’installer via la ligne de commande en exécutant :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure><h1 id="Detection-de-visage-avec-OpenCV"><a href="#Detection-de-visage-avec-OpenCV" class="headerlink" title="Détection de visage avec OpenCV"></a>Détection de visage avec OpenCV</h1><h2 id="Importer-les-bibliotheques"><a href="#Importer-les-bibliotheques" class="headerlink" title="Importer les bibliothèques"></a>Importer les bibliothèques</h2><p>Tout d’abord, importons les bibliothèques nécessaires.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br></pre></td></tr></table></figure><h2 id="Charger-l’image"><a href="#Charger-l’image" class="headerlink" title="Charger l’image"></a>Charger l’image</h2><p>Chargeons une image à partir de laquelle nous voulons détecter les visages.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image = cv2.imread(<span class="string">&#x27;face.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="Initialiser-le-classificateur"><a href="#Initialiser-le-classificateur" class="headerlink" title="Initialiser le classificateur"></a>Initialiser le classificateur</h2><p>OpenCV fournit des classificateurs pré-entraînés pour la détection de visages. Nous allons utiliser le classificateur Haar Cascade pour détecter les visages.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + <span class="string">&#x27;haarcascade_frontalface_default.xml&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="Detection-de-visage"><a href="#Detection-de-visage" class="headerlink" title="Détection de visage"></a>Détection de visage</h2><p>Maintenant, effectuons la détection de visage en utilisant le classificateur Haar Cascade.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">faces = face_cascade.detectMultiScale(image, scaleFactor=<span class="number">1.1</span>, minNeighbors=<span class="number">5</span>, minSize=(<span class="number">30</span>, <span class="number">30</span>))</span><br></pre></td></tr></table></figure><h2 id="Dessiner-des-rectangles-autour-des-visages-detectes"><a href="#Dessiner-des-rectangles-autour-des-visages-detectes" class="headerlink" title="Dessiner des rectangles autour des visages détectés"></a>Dessiner des rectangles autour des visages détectés</h2><p>Parcourons les visages détectés et dessinons des rectangles autour d’eux.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (x, y, w, h) <span class="keyword">in</span> faces:</span><br><span class="line">    cv2.rectangle(image, (x, y), (x+w, y+h), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="Afficher-l’image-avec-les-visages-detectes"><a href="#Afficher-l’image-avec-les-visages-detectes" class="headerlink" title="Afficher l’image avec les visages détectés"></a>Afficher l’image avec les visages détectés</h2><p>Affichons l’image avec les visages détectés.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">&#x27;Detected Faces&#x27;</span>, image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>La détection de visage est une application puissante de la vision par ordinateur avec de nombreuses applications pratiques. Elle est utilisée dans divers domaines tels que la sécurité, la surveillance, la photographie, et même les filtres de selfie sur les réseaux sociaux. En maîtrisant les techniques de détection de visage avec OpenCV, vous pouvez explorer un nouveau monde d’innovations et de possibilités.</p><p>N’hésitez pas à expérimenter davantage avec les paramètres du classificateur et à explorer d’autres fonctionnalités offertes par OpenCV pour améliorer vos compétences en détection de visage. Amusez-vous à découvrir les nombreux usages et applications passionnantes de cette technologie ! </p><p><strong>Ressources supplémentaires:</strong></p><ul><li><a href="https://opencv.org/">OpenCV Documentation</a></li><li><a href="https://github.com/opencv/opencv">GitHub repository</a></li></ul><p>Avec un peu de pratique et de créativité, les possibilités sont infinies !</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;Dans le domaine de la vision p</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://magic-nikos.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="https://magic-nikos.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://magic-nikos.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Calibration de caméra</title>
    <link href="https://magic-nikos.github.io/2024/03/01/Calibration-de-camera/"/>
    <id>https://magic-nikos.github.io/2024/03/01/Calibration-de-camera/</id>
    <published>2024-03-01T14:27:11.000Z</published>
    <updated>2024-03-01T14:27:29.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Calibration-de-camera-avec-OpenCV"><a href="#Calibration-de-camera-avec-OpenCV" class="headerlink" title="Calibration de caméra avec OpenCV"></a>Calibration de caméra avec OpenCV</h1><p>Dans le domaine de la vision par ordinateur, la calibration de caméra est une étape cruciale pour corriger les distorsions et les erreurs de perspective qui peuvent affecter les images capturées par une caméra. Grâce à OpenCV, une bibliothèque populaire d’analyse d’images en temps réel, il est possible de réaliser cette calibration de manière efficace. Dans cet article, nous allons explorer les bases de la calibration de caméra avec OpenCV, en expliquant chaque étape de manière claire et concise.</p><h2 id="Qu’est-ce-que-la-calibration-de-camera"><a href="#Qu’est-ce-que-la-calibration-de-camera" class="headerlink" title="Qu’est-ce que la calibration de caméra ?"></a>Qu’est-ce que la calibration de caméra ?</h2><p>La calibration de caméra consiste à estimer les paramètres intrinsèques et extrinsèques d’une caméra, tels que la distorsion radiale, tangentielle, la focale, et la position de la caméra par rapport à la scène. Ces paramètres permettent de rectifier les déformations géométriques et d’obtenir des mesures précises dans les images capturées par la caméra.</p><h2 id="Etapes-de-la-calibration-de-camera-avec-OpenCV"><a href="#Etapes-de-la-calibration-de-camera-avec-OpenCV" class="headerlink" title="Étapes de la calibration de caméra avec OpenCV"></a>Étapes de la calibration de caméra avec OpenCV</h2><h3 id="1-Preparation-des-images-de-calibration"><a href="#1-Preparation-des-images-de-calibration" class="headerlink" title="1. Préparation des images de calibration"></a>1. Préparation des images de calibration</h3><p>Pour commencer, vous aurez besoin d’un ensemble d’images de calibration capturées par votre caméra. Ces images doivent contenir des motifs connus, tels que des grilles de calibration ou des motifs de calibration circulaires.</p><h3 id="2-Detection-des-coins-de-la-grille"><a href="#2-Detection-des-coins-de-la-grille" class="headerlink" title="2. Détection des coins de la grille"></a>2. Détection des coins de la grille</h3><p>Utilisez les fonctions de détection de coins d’OpenCV pour détecter les coins des motifs de calibration dans chaque image. Cela permettra d’obtenir les coordonnées des coins dans l’image.</p><p>Exemple de code pour la détection des coins avec OpenCV :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Charger une image de calibration</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;calibration_image.jpg&#x27;</span>)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Detection des coins avec la fonction findChessboardCorners</span></span><br><span class="line">ret, corners = cv2.findChessboardCorners(gray, (<span class="number">7</span>,<span class="number">6</span>), <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><h3 id="3-Calibration-de-la-camera"><a href="#3-Calibration-de-la-camera" class="headerlink" title="3. Calibration de la caméra"></a>3. Calibration de la caméra</h3><p>En utilisant les coordonnées des coins détectés dans les images de calibration, OpenCV peut calculer les paramètres intrinsèques et extrinsèques de la caméra en utilisant des techniques comme la méthode de Zhang.</p><p>Exemple de code pour la calibration de la caméra :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Calcul des paramètres de calibration</span></span><br><span class="line">ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-<span class="number">1</span>], <span class="literal">None</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><h3 id="4-Evaluation-de-la-qualite-de-la-calibration"><a href="#4-Evaluation-de-la-qualite-de-la-calibration" class="headerlink" title="4. Évaluation de la qualité de la calibration"></a>4. Évaluation de la qualité de la calibration</h3><p>Après la calibration, il est important d’évaluer la qualité des paramètres obtenus en utilisant des mesures telles que l’erreur de re-projection. Cela permet de vérifier la précision de la calibration et d’apporter d’éventuelles corrections.</p><h2 id="Applications-de-la-calibration-de-camera"><a href="#Applications-de-la-calibration-de-camera" class="headerlink" title="Applications de la calibration de caméra"></a>Applications de la calibration de caméra</h2><p>La calibration de caméra est essentielle pour de nombreuses applications de vision par ordinateur, telles que la réalité augmentée, la robotique, et l’analyse d’images médicales. En corrigeant les distorsions de l’image, on peut obtenir des mesures précises et une meilleure compréhension de la scène observée.</p><p>En conclusion, la calibration de caméra avec OpenCV est un processus fondamental pour garantir des analyses d’images précises et fiables. En comprenant les étapes de la calibration et en utilisant les outils fournis par OpenCV, il est possible d’obtenir des résultats de haute qualité pour une variété d’applications.</p><p>Pour en savoir plus sur la calibration de caméra avec OpenCV, consultez la documentation officielle d’OpenCV : <a href="https://docs.opencv.org/master/d9/d0c/group__calib3d.html">Calibration de caméra avec OpenCV</a>.</p><hr><p>Merci d’avoir lu cet article sur la calibration de caméra avec OpenCV. N’hésitez pas à explorer davantage ce sujet passionnant et à expérimenter par vous-même pour approfondir vos connaissances en vision par ordinateur.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Calibration-de-camera-avec-OpenCV&quot;&gt;&lt;a href=&quot;#Calibration-de-camera-avec-OpenCV&quot; class=&quot;headerlink&quot; title=&quot;Calibration de caméra avec</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://magic-nikos.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="https://magic-nikos.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://magic-nikos.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Suivi d&#39;objets</title>
    <link href="https://magic-nikos.github.io/2024/03/01/Suivi-d-objets/"/>
    <id>https://magic-nikos.github.io/2024/03/01/Suivi-d-objets/</id>
    <published>2024-03-01T14:26:56.000Z</published>
    <updated>2024-03-01T14:27:08.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Suivi-d’objets-avec-OpenCV"><a href="#Suivi-d’objets-avec-OpenCV" class="headerlink" title="Suivi d’objets avec OpenCV"></a>Suivi d’objets avec OpenCV</h1><p>Bienvenue dans cet article qui va vous initier au suivi d’objets avec OpenCV! Le suivi d’objets est une technique essentielle en vision par ordinateur permettant de suivre un objet spécifique dans une séquence d’images.</p><h2 id="Qu’est-ce-que-le-suivi-d’objets"><a href="#Qu’est-ce-que-le-suivi-d’objets" class="headerlink" title="Qu’est-ce que le suivi d’objets?"></a>Qu’est-ce que le suivi d’objets?</h2><p>Le suivi d’objets consiste à localiser et suivre la trajectoire d’un objet spécifique à travers une séquence d’images. Cela peut être utile dans de nombreuses applications telles que la surveillance vidéo, la réalité augmentée, la robotique, et bien d’autres.</p><h3 id="Comment-fonctionne-le-suivi-d’objets"><a href="#Comment-fonctionne-le-suivi-d’objets" class="headerlink" title="Comment fonctionne le suivi d’objets?"></a>Comment fonctionne le suivi d’objets?</h3><p>Le suivi d’objets peut être réalisé en utilisant des techniques de détection d’objets et de suivi de mouvement. OpenCV offre des fonctionnalités puissantes pour implémenter ces techniques. Une approche courante consiste à utiliser des algorithmes comme le suivi optique ou les trackers disponibles dans OpenCV.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Exemple de suivi d&#x27;objets avec le tracker BOOSTING</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">tracker = cv2.TrackerBoosting_create()</span><br><span class="line">video = cv2.VideoCapture(<span class="string">&#x27;video.mp4&#x27;</span>)</span><br><span class="line">ok, frame = video.read()</span><br><span class="line">bbox = cv2.selectROI(frame, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">tracker.init(frame, bbox)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ok, frame = video.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    ok, bbox = tracker.update(frame)</span><br><span class="line">    <span class="keyword">if</span> ok:</span><br><span class="line">        p1 = (<span class="built_in">int</span>(bbox[<span class="number">0</span>]), <span class="built_in">int</span>(bbox[<span class="number">1</span>]))</span><br><span class="line">        p2 = (<span class="built_in">int</span>(bbox[<span class="number">0</span>] + bbox[<span class="number">2</span>]), <span class="built_in">int</span>(bbox[<span class="number">1</span>] + bbox[<span class="number">3</span>]))</span><br><span class="line">        cv2.rectangle(frame, p1, p2, (<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    cv2.imshow(<span class="string">&#x27;Tracking&#x27;</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="Applications-du-suivi-d’objets"><a href="#Applications-du-suivi-d’objets" class="headerlink" title="Applications du suivi d’objets"></a>Applications du suivi d’objets</h2><p>Le suivi d’objets trouve de nombreuses applications pratiques comme la surveillance de personnes, le suivi de véhicules, la réalité augmentée dans les jeux, la navigation des robots autonomes, et bien plus encore.</p><p>En conclusion, le suivi d’objets est une compétence clé en vision par ordinateur. En combinant les fonctionnalités d’OpenCV et les concepts de base du suivi d’objets, vous pourrez créer des applications innovantes et passionnantes!</p><p>N’hésitez pas à explorer davantage les fonctionnalités d’OpenCV pour enrichir vos connaissances en vision par ordinateur. Amusez-vous à explorer le monde du suivi d’objets!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Suivi-d’objets-avec-OpenCV&quot;&gt;&lt;a href=&quot;#Suivi-d’objets-avec-OpenCV&quot; class=&quot;headerlink&quot; title=&quot;Suivi d’objets avec OpenCV&quot;&gt;&lt;/a&gt;Suivi d’</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://magic-nikos.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="https://magic-nikos.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://magic-nikos.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Détection de mouvement</title>
    <link href="https://magic-nikos.github.io/2024/03/01/Detection-de-mouvement/"/>
    <id>https://magic-nikos.github.io/2024/03/01/Detection-de-mouvement/</id>
    <published>2024-03-01T14:26:39.000Z</published>
    <updated>2024-03-01T14:26:54.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Article-pedagogique-Detection-de-mouvement-avec-OpenCV"><a href="#Article-pedagogique-Detection-de-mouvement-avec-OpenCV" class="headerlink" title="Article pédagogique : Détection de mouvement avec OpenCV"></a>Article pédagogique : Détection de mouvement avec OpenCV</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>La détection de mouvement est une fonctionnalité clé en traitement d’images et de vidéos. OpenCV, une bibliothèque open-source, offre des outils puissants pour détecter les changements dans une séquence d’images. Dans cet article, nous allons explorer les différentes méthodes disponibles pour la détection de mouvement en utilisant OpenCV.</p><h2 id="Prerequis"><a href="#Prerequis" class="headerlink" title="Prérequis"></a>Prérequis</h2><p>Avant de commencer, assurez-vous d’avoir installé OpenCV sur votre système. Si ce n’est pas déjà fait, vous pouvez suivre les instructions d’installation sur le site officiel d’OpenCV.</p><h2 id="Detection-de-mouvement-avec-OpenCV"><a href="#Detection-de-mouvement-avec-OpenCV" class="headerlink" title="Détection de mouvement avec OpenCV"></a>Détection de mouvement avec OpenCV</h2><h3 id="1-Capturer-une-video"><a href="#1-Capturer-une-video" class="headerlink" title="1. Capturer une vidéo"></a>1. Capturer une vidéo</h3><p>La première étape consiste à capturer une vidéo à l’aide d’OpenCV. Vous pouvez utiliser une webcam en direct ou charger une vidéo existante.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)  <span class="comment"># Capture vidéo à partir de la webcam</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;Video&#x27;</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="2-Conversion-en-niveaux-de-gris"><a href="#2-Conversion-en-niveaux-de-gris" class="headerlink" title="2. Conversion en niveaux de gris"></a>2. Conversion en niveaux de gris</h3><p>Avant de détecter le mouvement, il est souvent utile de convertir l’image en niveaux de gris. Cela simplifie le traitement et réduit le bruit.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br></pre></td></tr></table></figure><h3 id="3-Detection-de-mouvement"><a href="#3-Detection-de-mouvement" class="headerlink" title="3. Détection de mouvement"></a>3. Détection de mouvement</h3><p>Il existe différentes approches pour détecter le mouvement, telles que la soustraction d’arrière-plan, la détection de contours et l’utilisation de l’optical flow. Voici un exemple de détection de mouvement en utilisant la soustraction d’arrière-plan :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">fgbg = cv2.createBackgroundSubtractorMOG2()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    fgmask = fgbg.apply(frame)</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;Foreground&#x27;</span>, fgmask)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>La détection de mouvement avec OpenCV offre de nombreuses applications pratiques, telles que la surveillance vidéo, l’analyse du comportement humain, la navigation autonome des robots, etc. En comprenant les concepts de base et en explorant les différentes techniques de détection de mouvement, vous serez en mesure de développer des solutions innovantes dans divers domaines.</p><p>En somme, la détection de mouvement avec OpenCV ouvre un large champ de possibilités qui ne demandent qu’à être explorées et exploitées.</p><p>N’hésitez pas à continuer à explorer les capacités d’OpenCV pour approfondir vos connaissances et créer des projets fascinants basés sur la détection de mouvement.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Article-pedagogique-Detection-de-mouvement-avec-OpenCV&quot;&gt;&lt;a href=&quot;#Article-pedagogique-Detection-de-mouvement-avec-OpenCV&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://magic-nikos.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="https://magic-nikos.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://magic-nikos.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Reconnaissance de formes</title>
    <link href="https://magic-nikos.github.io/2024/03/01/Reconnaissance-de-formes/"/>
    <id>https://magic-nikos.github.io/2024/03/01/Reconnaissance-de-formes/</id>
    <published>2024-03-01T14:26:25.000Z</published>
    <updated>2024-03-01T14:26:37.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reconnaissance-de-formes-en-OpenCV-Guide-pour-debutants"><a href="#Reconnaissance-de-formes-en-OpenCV-Guide-pour-debutants" class="headerlink" title="Reconnaissance de formes en OpenCV : Guide pour débutants"></a>Reconnaissance de formes en OpenCV : Guide pour débutants</h1><p>La reconnaissance de formes est une branche essentielle du traitement d’images, permettant d’identifier et de classer des formes, motifs ou objets dans une image en utilisant des algorithmes spécifiques. Dans cet article, nous allons explorer les bases de la reconnaissance de formes en OpenCV, une bibliothèque populaire de vision par ordinateur.</p><h2 id="Introduction-a-la-reconnaissance-de-formes"><a href="#Introduction-a-la-reconnaissance-de-formes" class="headerlink" title="Introduction à la reconnaissance de formes"></a>Introduction à la reconnaissance de formes</h2><p>La reconnaissance de formes est un processus complexe qui repose sur l’analyse des caractéristiques visuelles des objets pour les distinguer les uns des autres. En OpenCV, cela peut être réalisé en utilisant des techniques telles que la détection de contours, l’extraction de descripteurs et la correspondance de modèles.</p><h2 id="Detection-de-contours"><a href="#Detection-de-contours" class="headerlink" title="Détection de contours"></a>Détection de contours</h2><p>La détection de contours est une étape cruciale dans la reconnaissance de formes. Elle permet d’extraire les contours des objets présents dans une image en mettant en évidence les transitions d’intensité. Par exemple, en utilisant l’algorithme de Canny, nous pouvons détecter les bords d’une forme comme un cercle.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">image = cv2.imread(<span class="string">&#x27;forme.png&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">edges = cv2.Canny(image, <span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;Contours&#x27;</span>, edges)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="Extraction-de-descripteurs"><a href="#Extraction-de-descripteurs" class="headerlink" title="Extraction de descripteurs"></a>Extraction de descripteurs</h2><p>Une fois les contours détectés, nous pouvons extraire des descripteurs pour caractériser les formes. Les descripteurs sont des informations numériques qui décrivent les propriétés distinctives d’un objet, facilitant ainsi sa comparaison avec d’autres formes similaires.</p><h2 id="Correspondance-de-modeles"><a href="#Correspondance-de-modeles" class="headerlink" title="Correspondance de modèles"></a>Correspondance de modèles</h2><p>La correspondance de modèles consiste à comparer les descripteurs extraits des formes pour rechercher des similitudes. Par exemple, en utilisant l’algorithme de correspondance de points d’intérêt, nous pouvons identifier une forme spécifique parmi plusieurs formes enregistrées.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>En conclusion, la reconnaissance de formes en OpenCV ouvre la voie à de nombreuses applications passionnantes telles que la détection d’objets, la reconnaissance faciale, la lecture optique de caractères, etc. En maîtrisant les concepts de base et les techniques avancées de la reconnaissance de formes, vous pourrez explorer un large éventail de domaines de la vision par ordinateur.</p><p>N’hésitez pas à expérimenter avec les codes fournis et à explorer davantage les fonctionnalités d’OpenCV pour approfondir vos connaissances en reconnaissance de formes. Amusez-vous à découvrir les innombrables possibilités offertes par ce domaine fascinant !</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Reconnaissance-de-formes-en-OpenCV-Guide-pour-debutants&quot;&gt;&lt;a href=&quot;#Reconnaissance-de-formes-en-OpenCV-Guide-pour-debutants&quot; class=&quot;h</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://magic-nikos.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="https://magic-nikos.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://magic-nikos.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Détection de formes</title>
    <link href="https://magic-nikos.github.io/2024/03/01/Detection-de-formes/"/>
    <id>https://magic-nikos.github.io/2024/03/01/Detection-de-formes/</id>
    <published>2024-03-01T14:26:06.000Z</published>
    <updated>2024-03-01T14:26:22.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction-a-la-detection-de-formes-avec-OpenCV"><a href="#Introduction-a-la-detection-de-formes-avec-OpenCV" class="headerlink" title="Introduction à la détection de formes avec OpenCV"></a>Introduction à la détection de formes avec OpenCV</h1><p>Bienvenue dans cet article qui vous initiera à la détection de formes en utilisant OpenCV. La détection de formes est une tâche fondamentale en traitement d’images et peut être appliquée dans de nombreux domaines tels que la vision par ordinateur, la reconnaissance d’objets et la robotique. Dans cet article, nous allons aborder les concepts de base pour détecter des formes géométriques simples telles que les cercles, les rectangles et les triangles. </p><h2 id="Installation-d’OpenCV"><a href="#Installation-d’OpenCV" class="headerlink" title="Installation d’OpenCV"></a>Installation d’OpenCV</h2><p>Avant de commencer, assurez-vous d’avoir OpenCV installé sur votre machine. Vous pouvez l’installer en utilisant pip :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure><h2 id="Chargement-de-l’image"><a href="#Chargement-de-l’image" class="headerlink" title="Chargement de l’image"></a>Chargement de l’image</h2><p>Tout d’abord, chargez une image sur laquelle vous souhaitez détecter des formes. Voici un exemple de code pour charger une image en utilisant OpenCV :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">image = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="Detection-de-cercles"><a href="#Detection-de-cercles" class="headerlink" title="Détection de cercles"></a>Détection de cercles</h2><p>La détection de cercles peut être réalisée en utilisant la transformée de Hough circulaire. Voici un exemple de code pour détecter des cercles dans une image :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">image_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">circles = cv2.HoughCircles(image_gray, cv2.HOUGH_GRADIENT, dp=<span class="number">1</span>, minDist=<span class="number">20</span>, param1=<span class="number">50</span>, param2=<span class="number">30</span>, minRadius=<span class="number">0</span>, maxRadius=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> circles <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    circles = np.uint16(np.around(circles))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> circles[<span class="number">0</span>, :]:</span><br><span class="line">        cv2.circle(image, (i[<span class="number">0</span>], i[<span class="number">1</span>]), i[<span class="number">2</span>], (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="Detection-de-rectangles"><a href="#Detection-de-rectangles" class="headerlink" title="Détection de rectangles"></a>Détection de rectangles</h2><p>Pour détecter des rectangles, nous pouvons utiliser des contours et l’approximation de la forme. Voici un exemple de code pour détecter des rectangles dans une image :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contours, _ = cv2.findContours(image_gray, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> contour <span class="keyword">in</span> contours:</span><br><span class="line">    epsilon = <span class="number">0.04</span> * cv2.arcLength(contour, <span class="literal">True</span>)</span><br><span class="line">    approx = cv2.approxPolyDP(contour, epsilon, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(approx) == <span class="number">4</span>:</span><br><span class="line">        cv2.drawContours(image, [approx], <span class="number">0</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="Detection-de-triangles"><a href="#Detection-de-triangles" class="headerlink" title="Détection de triangles"></a>Détection de triangles</h2><p>Pour détecter des triangles, nous pouvons appliquer des techniques similaires à celles des rectangles en ajustant les critères de forme. Voici un exemple de code pour détecter des triangles dans une image :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> contour <span class="keyword">in</span> contours:</span><br><span class="line">    epsilon = <span class="number">0.03</span> * cv2.arcLength(contour, <span class="literal">True</span>)</span><br><span class="line">    approx = cv2.approxPolyDP(contour, epsilon, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(approx) == <span class="number">3</span>:</span><br><span class="line">        cv2.drawContours(image, [approx], <span class="number">0</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>En conclusion, la détection de formes avec OpenCV est une tâche intéressante qui peut être implémentée en utilisant diverses techniques telles que la transformée de Hough et l’approximation de contours. Les applications de la détection de formes sont nombreuses, allant de la détection d’objets dans des images à la reconnaissance de motifs dans des scènes complexes. En continuant à explorer et à expérimenter avec OpenCV, vous pourrez développer des applications plus avancées de vision par ordinateur. Amusez-vous à détecter des formes !</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction-a-la-detection-de-formes-avec-OpenCV&quot;&gt;&lt;a href=&quot;#Introduction-a-la-detection-de-formes-avec-OpenCV&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://magic-nikos.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="https://magic-nikos.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://magic-nikos.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Segmentation d&#39;images</title>
    <link href="https://magic-nikos.github.io/2024/03/01/Segmentation-d-images/"/>
    <id>https://magic-nikos.github.io/2024/03/01/Segmentation-d-images/</id>
    <published>2024-03-01T14:25:45.000Z</published>
    <updated>2024-03-01T14:26:04.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Article-educatif-Introduction-a-la-Segmentation-d’images-avec-OpenCV"><a href="#Article-educatif-Introduction-a-la-Segmentation-d’images-avec-OpenCV" class="headerlink" title="Article éducatif : Introduction à la Segmentation d’images avec OpenCV"></a>Article éducatif : Introduction à la Segmentation d’images avec OpenCV</h1><p>Bienvenue dans ce guide pédagogique dédié à la segmentation d’images avec OpenCV, un domaine passionnant de la vision par ordinateur. Dans cet article, nous allons explorer ce qu’est la segmentation d’images, pourquoi c’est important et comment vous pouvez commencer à l’implémenter en utilisant la bibliothèque OpenCV.</p><h2 id="Qu’est-ce-que-la-segmentation-d’images"><a href="#Qu’est-ce-que-la-segmentation-d’images" class="headerlink" title="Qu’est-ce que la segmentation d’images ?"></a>Qu’est-ce que la segmentation d’images ?</h2><p>La segmentation d’images est le processus de partitionnement d’une image en plusieurs segments pour en simplifier la représentation ou en faciliter l’analyse. Elle est largement utilisée dans divers domaines tels que la reconnaissance d’objets, la détection de contours et la classification d’images. Plus simplement, la segmentation d’images consiste à diviser une image en différentes régions ou objets de manière automatique ou semi-automatique.</p><h2 id="Prerequis-necessaires"><a href="#Prerequis-necessaires" class="headerlink" title="Prérequis nécessaires"></a>Prérequis nécessaires</h2><p>Avant de commencer à segmenter des images, assurez-vous d’avoir installé OpenCV sur votre système. Si ce n’est pas déjà fait, vous pouvez suivre les instructions d’installation sur le site officiel d’OpenCV.</p><h2 id="Methodes-de-segmentation-d’images"><a href="#Methodes-de-segmentation-d’images" class="headerlink" title="Méthodes de segmentation d’images"></a>Méthodes de segmentation d’images</h2><h3 id="1-Thresholding"><a href="#1-Thresholding" class="headerlink" title="1. Thresholding"></a>1. Thresholding</h3><p>Le seuillage est l’une des méthodes les plus simples de segmentation d’images. Il consiste à définir un seuil et à classifier chaque pixel de l’image comme faisant partie de l’avant-plan ou de l’arrière-plan en fonction de sa valeur de luminosité.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">ret, thresholded_img = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;Thresholded Image&#x27;</span>, thresholded_img)</span><br></pre></td></tr></table></figure><h3 id="2-Contour-detection"><a href="#2-Contour-detection" class="headerlink" title="2. Contour detection"></a>2. Contour detection</h3><p>La détection de contours est une méthode avancée de segmentation qui consiste à détecter les contours des objets présents dans une image en mettant en évidence les changements soudains de luminosité.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>)</span><br><span class="line">gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">contours, hierarchy = cv2.findContours(gray_img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">cv2.drawContours(img, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">3</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;Contour Image&#x27;</span>, img)</span><br></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>La segmentation d’images est une étape fondamentale dans le traitement d’images et la vision par ordinateur. En maîtrisant les différentes techniques de segmentation disponibles dans OpenCV, vous pourrez ouvrir la porte à de nombreuses applications passionnantes telles que la détection d’objets, la reconnaissance de formes et la surveillance vidéo. Explorez, expérimentez et laissez libre cours à votre créativité pour découvrir tout le potentiel de la segmentation d’images !</p><p>N’hésitez pas à consulter la documentation officielle d’OpenCV pour en savoir plus sur les techniques avancées de segmentation d’images et les applications pratiques associées. Amusez-vous bien !</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Article-educatif-Introduction-a-la-Segmentation-d’images-avec-OpenCV&quot;&gt;&lt;a href=&quot;#Article-educatif-Introduction-a-la-Segmentation-d’im</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://magic-nikos.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="https://magic-nikos.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://magic-nikos.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Transformations d&#39;images</title>
    <link href="https://magic-nikos.github.io/2024/03/01/Transformations-d-images/"/>
    <id>https://magic-nikos.github.io/2024/03/01/Transformations-d-images/</id>
    <published>2024-03-01T14:25:31.000Z</published>
    <updated>2024-03-01T14:25:42.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Article-educatif-Decouvrez-les-Transformations-d’images-avec-OpenCV"><a href="#Article-educatif-Decouvrez-les-Transformations-d’images-avec-OpenCV" class="headerlink" title="Article éducatif: Découvrez les Transformations d’images avec OpenCV"></a>Article éducatif: Découvrez les Transformations d’images avec OpenCV</h1><p>Bienvenue dans cet article dédié aux transformations d’images avec OpenCV, un outil puissant pour le traitement d’images. Les transformations d’images permettent de modifier la géométrie et l’apparence des images, ouvrant ainsi un large éventail de possibilités pour améliorer et analyser des images. Dans cet article, nous explorerons les bases des transformations d’images avec OpenCV pour vous aider à démarrer.</p><h2 id="Qu’est-ce-que-les-transformations-d’images"><a href="#Qu’est-ce-que-les-transformations-d’images" class="headerlink" title="Qu’est-ce que les transformations d’images ?"></a>Qu’est-ce que les transformations d’images ?</h2><p>Les transformations d’images consistent à appliquer des modifications géométriques à une image, comme la translation, la rotation, le redimensionnement, ou la distorsion. Ces transformations sont cruciales dans le domaine du traitement d’images pour corriger les distorsions, les perspectives ou encore pour aligner des images.</p><h3 id="Rotation-d’une-image"><a href="#Rotation-d’une-image" class="headerlink" title="Rotation d’une image"></a>Rotation d’une image</h3><p>L’une des transformations les plus courantes est la rotation d’une image. Avec OpenCV, vous pouvez facilement effectuer une rotation en spécifiant l’angle de rotation souhaité. Voici un exemple en Python:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">image = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>)</span><br><span class="line">h, w = image.shape[:<span class="number">2</span>]</span><br><span class="line">center = (w // <span class="number">2</span>, h // <span class="number">2</span>)</span><br><span class="line">angle = <span class="number">45</span></span><br><span class="line">rotation_matrix = cv2.getRotationMatrix2D(center, angle, <span class="number">1</span>)</span><br><span class="line">rotated_image = cv2.warpAffine(image, rotation_matrix, (w, h))</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;Rotated Image&#x27;</span>, rotated_image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="Redimensionnement-d’une-image"><a href="#Redimensionnement-d’une-image" class="headerlink" title="Redimensionnement d’une image"></a>Redimensionnement d’une image</h3><p>Une autre opération de transformation utile est le redimensionnement d’une image. Cela peut être utile pour ajuster la taille de l’image pour une visualisation ou pour la prétraiter avant d’autres opérations. Voici comment redimensionner une image en utilisant OpenCV:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resized_image = cv2.resize(image, (new_width, new_height), interpolation=cv2.INTER_LINEAR)</span><br></pre></td></tr></table></figure><h2 id="Applications-des-transformations-d’images"><a href="#Applications-des-transformations-d’images" class="headerlink" title="Applications des transformations d’images"></a>Applications des transformations d’images</h2><p>Les transformations d’images sont largement utilisées dans de nombreux domaines tels que la vision par ordinateur, la réalité augmentée, la reconnaissance d’objets, la cartographie, etc. En maîtrisant les transformations d’images avec OpenCV, vous pourrez améliorer la qualité des images, effectuer des analyses plus précises et concevoir des applications innovantes.</p><p>En conclusion, les transformations d’images avec OpenCV sont essentielles pour le traitement d’images et offrent un potentiel infini pour explorer et manipuler des images. Nous espérons que cet article vous a donné un aperçu des concepts de base des transformations d’images et vous a inspiré à explorer davantage ce domaine fascinant. Amusez-vous à expérimenter avec les transformations d’images et découvrez les possibilités infinies qui s’offrent à vous !</p><hr><p>N’hésitez pas à explorer davantage les transformations d’images avec OpenCV et à partager vos découvertes avec la communauté !</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Article-educatif-Decouvrez-les-Transformations-d’images-avec-OpenCV&quot;&gt;&lt;a href=&quot;#Article-educatif-Decouvrez-les-Transformations-d’imag</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://magic-nikos.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="https://magic-nikos.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://magic-nikos.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Analyse des couleurs</title>
    <link href="https://magic-nikos.github.io/2024/03/01/Analyse-des-couleurs/"/>
    <id>https://magic-nikos.github.io/2024/03/01/Analyse-des-couleurs/</id>
    <published>2024-03-01T14:25:14.000Z</published>
    <updated>2024-03-01T14:25:29.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction-a-l’analyse-des-couleurs-avec-OpenCV"><a href="#Introduction-a-l’analyse-des-couleurs-avec-OpenCV" class="headerlink" title="Introduction à l’analyse des couleurs avec OpenCV"></a>Introduction à l’analyse des couleurs avec OpenCV</h1><p>L’analyse des couleurs est l’une des fonctionnalités les plus intéressantes et populaires de la bibliothèque OpenCV. Que vous soyez un développeur débutant ou expérimenté, comprendre comment traiter les couleurs à l’aide d’OpenCV est essentiel pour de nombreux projets de vision par ordinateur. Dans cet article, nous allons explorer les bases de l’analyse des couleurs avec OpenCV, en couvrant différents concepts et techniques pour vous aider à maîtriser cette compétence fondamentale.</p><h2 id="1-Introduction-a-la-manipulation-des-couleurs"><a href="#1-Introduction-a-la-manipulation-des-couleurs" class="headerlink" title="1. Introduction à la manipulation des couleurs"></a>1. Introduction à la manipulation des couleurs</h2><p>Avant de plonger dans les détails techniques, il est important de comprendre comment les couleurs sont représentées dans OpenCV. En général, les couleurs sont souvent représentées en utilisant le modèle RGB (Rouge, Vert, Bleu), où chaque pixel est composé de trois canaux de couleur.</p><p>Pour charger une image et afficher ses canaux de couleur en utilisant OpenCV, vous pouvez utiliser le code suivant :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">image = cv2.imread(<span class="string">&#x27;example.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="2-Extraction-des-couleurs-dominantes"><a href="#2-Extraction-des-couleurs-dominantes" class="headerlink" title="2. Extraction des couleurs dominantes"></a>2. Extraction des couleurs dominantes</h2><p>L’extraction des couleurs dominantes dans une image est une tâche courante en traitement d’images. OpenCV offre des fonctions puissantes pour extraire les couleurs les plus représentatives d’une image. Voici un exemple de code pour extraire les couleurs dominantes d’une image :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">image = cv2.imread(<span class="string">&#x27;example.jpg&#x27;</span>)</span><br><span class="line">image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)</span><br><span class="line"></span><br><span class="line">pixels = np.float32(image.reshape(-<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">n_colors = <span class="number">5</span></span><br><span class="line">criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, <span class="number">200</span>, <span class="number">.1</span>)</span><br><span class="line">flags = cv2.KMEANS_RANDOM_CENTERS</span><br><span class="line"></span><br><span class="line">_, labels, palette = cv2.kmeans(pixels, n_colors, <span class="literal">None</span>, criteria, <span class="number">10</span>, flags)</span><br><span class="line"></span><br><span class="line">quantized = palette[labels.flatten()]</span><br><span class="line">quantized = quantized.reshape(image.shape)</span><br><span class="line"></span><br><span class="line">plt.imshow(quantized)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="3-Detection-des-couleurs-specifiques"><a href="#3-Detection-des-couleurs-specifiques" class="headerlink" title="3. Détection des couleurs spécifiques"></a>3. Détection des couleurs spécifiques</h2><p>La détection des couleurs spécifiques dans une image peut être réalisée en seuillant les canaux de couleur appropriés. Par exemple, supposons que vous vouliez détecter les objets rouges dans une image, vous pouvez utiliser la méthode suivante :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">image = cv2.imread(<span class="string">&#x27;example.jpg&#x27;</span>)</span><br><span class="line">hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)</span><br><span class="line"></span><br><span class="line">lower_red = np.array([<span class="number">0</span>,<span class="number">50</span>,<span class="number">50</span>])</span><br><span class="line">upper_red = np.array([<span class="number">10</span>,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line"></span><br><span class="line">mask = cv2.inRange(hsv, lower_red, upper_red)</span><br><span class="line">result = cv2.bitwise_and(image, image, mask=mask)</span><br><span class="line"></span><br><span class="line">plt.imshow(result)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>En résumé, l’analyse des couleurs avec OpenCV est une compétence précieuse pour tout développeur travaillant avec des images et des vidéos. En comprenant comment manipuler les couleurs, extraire les couleurs dominantes et détecter des couleurs spécifiques, vous serez en mesure de créer des applications de traitement d’images plus avancées.</p><p>Que ce soit pour la reconnaissance d’objets, la segmentation d’images ou la détection de mouvements, la maîtrise de l’analyse des couleurs avec OpenCV ouvre la voie à de nombreuses applications fascinantes dans le domaine de la vision par ordinateur.</p><p>N’hésitez pas à explorer davantage cette fonctionnalité puissante d’OpenCV et à expérimenter avec vos propres projets pour approfondir vos connaissances et compétences en matière d’analyse des couleurs.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction-a-l’analyse-des-couleurs-avec-OpenCV&quot;&gt;&lt;a href=&quot;#Introduction-a-l’analyse-des-couleurs-avec-OpenCV&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://magic-nikos.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="https://magic-nikos.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://magic-nikos.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Détection de contours</title>
    <link href="https://magic-nikos.github.io/2024/03/01/Detection-de-contours/"/>
    <id>https://magic-nikos.github.io/2024/03/01/Detection-de-contours/</id>
    <published>2024-03-01T14:24:56.000Z</published>
    <updated>2024-03-01T14:25:12.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Article-educatif-sur-la-Detection-de-contours-avec-OpenCV"><a href="#Article-educatif-sur-la-Detection-de-contours-avec-OpenCV" class="headerlink" title="Article éducatif sur la Détection de contours avec OpenCV"></a>Article éducatif sur la Détection de contours avec OpenCV</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Bienvenue dans ce guide dédié à la détection de contours avec OpenCV, une bibliothèque populaire pour le traitement d’images en vision par ordinateur. La détection de contours est une technique fondamentale en vision par ordinateur, utilisée pour extraire des informations importantes des images. Dans cet article, nous allons explorer les concepts de base de la détection de contours, comment les implémenter en utilisant OpenCV, et leurs applications potentielles.</p><h2 id="Qu’est-ce-que-la-Detection-de-contours"><a href="#Qu’est-ce-que-la-Detection-de-contours" class="headerlink" title="Qu’est-ce que la Détection de contours ?"></a>Qu’est-ce que la Détection de contours ?</h2><p>La détection de contours consiste à identifier les frontières des objets présents dans une image. Ces contours sont des transitions brusques d’intensité, représentant les limites des objets. </p><h2 id="Methodes-de-detection-de-contours"><a href="#Methodes-de-detection-de-contours" class="headerlink" title="Méthodes de détection de contours"></a>Méthodes de détection de contours</h2><p>OpenCV propose plusieurs algorithmes de détection de contours. Les plus couramment utilisés sont :</p><ul><li>Canny</li><li>Sobel</li><li>Laplacian</li></ul><h2 id="Exemple-avec-l’algorithme-Canny"><a href="#Exemple-avec-l’algorithme-Canny" class="headerlink" title="Exemple avec l’algorithme Canny"></a>Exemple avec l’algorithme Canny</h2><p>Voici un exemple simple d’implémentation de la détection de contours en utilisant l’algorithme de Canny avec OpenCV en Python :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Charger une image en niveaux de gris</span></span><br><span class="line">image = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Appliquer l&#x27;algorithme de Canny pour détecter les contours</span></span><br><span class="line">edges = cv2.Canny(image, <span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Afficher l&#x27;image des contours détectés</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;Contours&#x27;</span>, edges)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>Dans cet exemple, l’algorithme de Canny est utilisé pour détecter les contours de l’image et les afficher. Les paramètres 100 et 200 représentent les seuils minimaux et maximaux pour la détection des contours.</p><h2 id="Applications-de-la-Detection-de-contours"><a href="#Applications-de-la-Detection-de-contours" class="headerlink" title="Applications de la Détection de contours"></a>Applications de la Détection de contours</h2><p>La détection de contours est largement utilisée dans de nombreuses applications, telles que :</p><ul><li>Détection d’objets</li><li>Reconnaissance de formes</li><li>Segmentation d’images</li><li>Analyse de mouvement</li></ul><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>La détection de contours est une technique essentielle en traitement d’images et en vision par ordinateur. Avec les algorithmes disponibles dans OpenCV, il est possible d’extraire des informations précieuses des images pour diverses applications. En maîtrisant les concepts de base de la détection de contours, vous serez en mesure d’explorer de nouvelles possibilités dans le domaine de la vision par ordinateur.</p><p>N’hésitez pas à expérimenter avec les différents algorithmes de détection de contours disponibles dans OpenCV et à explorer les multiples applications de cette technique puissante.</p><p><em>Article rédigé par [Votre Nom]</em></p><hr><p>Cet article éducatif a couvert les fondamentaux de la détection de contours avec OpenCV, en explorant les concepts clés, en présentant des exemples pratiques, et en mettant en avant les applications potentielles. J’espère que vous avez trouvé ces informations utiles et inspirantes pour explorer davantage ce passionnant domaine.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Article-educatif-sur-la-Detection-de-contours-avec-OpenCV&quot;&gt;&lt;a href=&quot;#Article-educatif-sur-la-Detection-de-contours-avec-OpenCV&quot; clas</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://magic-nikos.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="https://magic-nikos.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://magic-nikos.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Filtrage d&#39;images</title>
    <link href="https://magic-nikos.github.io/2024/03/01/Filtrage-d-images/"/>
    <id>https://magic-nikos.github.io/2024/03/01/Filtrage-d-images/</id>
    <published>2024-03-01T14:24:39.000Z</published>
    <updated>2024-03-01T14:24:54.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Article-educatif-Introduction-au-Filtrage-d’images-avec-OpenCV"><a href="#Article-educatif-Introduction-au-Filtrage-d’images-avec-OpenCV" class="headerlink" title="Article éducatif : Introduction au Filtrage d’images avec OpenCV"></a>Article éducatif : Introduction au Filtrage d’images avec OpenCV</h1><hr><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Le filtrage d’images est une technique essentielle en traitement d’images permettant d’améliorer la qualité des images, de réduire le bruit ou d’extraire des informations spécifiques. Dans cet article, nous allons explorer les bases du filtrage d’images en utilisant la bibliothèque OpenCV, très populaire dans le domaine de la vision par ordinateur.</p><hr><h2 id="Qu’est-ce-que-le-filtrage-d’images"><a href="#Qu’est-ce-que-le-filtrage-d’images" class="headerlink" title="Qu’est-ce que le filtrage d’images?"></a>Qu’est-ce que le filtrage d’images?</h2><p>Le filtrage d’images consiste à appliquer une transformation à une image en passant par un masque ou un noyau. Ce masque agit comme un filtre qui modifie les pixels de l’image en fonction de leur voisinage. Il existe différents types de filtrage, mais les plus communs sont le filtrage linéaire et le filtrage non linéaire.</p><h3 id="Exemple"><a href="#Exemple" class="headerlink" title="Exemple:"></a>Exemple:</h3><p>Considérons une image en niveaux de gris où chaque pixel est représenté par une valeur de luminosité. En appliquant un filtre de lissage, les pixels de l’image seront modifiés en prenant en compte les valeurs de leurs voisins, créant ainsi une image plus douce et moins bruitée.</p><hr><h2 id="Filtrage-lineaire"><a href="#Filtrage-lineaire" class="headerlink" title="Filtrage linéaire"></a>Filtrage linéaire</h2><p>Le filtrage linéaire est une opération mathématique qui consiste à calculer la nouvelle valeur d’un pixel en fonction des valeurs de ses voisins pondérées par un noyau prédéfini. Les filtres linéaires les plus courants sont le filtre de convolution et le filtre de moyenne.</p><h3 id="Exemple-1"><a href="#Exemple-1" class="headerlink" title="Exemple:"></a>Exemple:</h3><p>Voici un exemple de code en Python utilisant OpenCV pour appliquer un filtre de moyenne à une image:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">image = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.float32)/<span class="number">25</span></span><br><span class="line">filtered_image = cv2.filter2D(image, -<span class="number">1</span>, kernel)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;Filtered Image&#x27;</span>, filtered_image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>Dans cet exemple, nous avons créé un kernel 5x5 pour effectuer une moyenne locale sur l’image.</p><hr><h2 id="Filtrage-non-lineaire"><a href="#Filtrage-non-lineaire" class="headerlink" title="Filtrage non linéaire"></a>Filtrage non linéaire</h2><p>Contrairement au filtrage linéaire, le filtrage non linéaire n’implique pas seulement une combinaison linéaire des pixels. Il comprend des opérations telles que la médiane, le maximum, le minimum et bien d’autres.</p><h3 id="Exemple-2"><a href="#Exemple-2" class="headerlink" title="Exemple:"></a>Exemple:</h3><p>Voici un exemple de filtrage médian en utilisant OpenCV:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">image = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>)</span><br><span class="line">filtered_image = cv2.medianBlur(image, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;Median Filtered Image&#x27;</span>, filtered_image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>Dans cet exemple, la fonction <code>medianBlur</code> remplace chaque pixel par la médiane des pixels voisins, ce qui est efficace pour réduire le bruit de type impulsionnel.</p><hr><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Le filtrage d’images est une technique puissante pour améliorer la qualité des images en réduisant le bruit, en renforçant les contours ou en extrayant des caractéristiques spécifiques. En explorant les techniques de filtrage linéaire et non linéaire avec OpenCV, vous serez en mesure de manipuler et d’améliorer vos images de manière significative.</p><p>Le filtrage d’images est largement utilisé dans de nombreux domaines tels que la reconnaissance de formes, la vision par ordinateur, la surveillance vidéo et la réalité augmentée, offrant ainsi un large champ d’applications pratiques.</p><hr><p>En suivant ce guide, vous avez maintenant acquis les connaissances de base sur le filtrage d’images avec OpenCV. Explorez davantage les différents types de filtres et expérimentez-les pour découvrir l’impact qu’ils peuvent avoir sur vos images. N’ayez pas peur d’expérimenter et de laisser libre cours à votre créativité !</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Article-educatif-Introduction-au-Filtrage-d’images-avec-OpenCV&quot;&gt;&lt;a href=&quot;#Article-educatif-Introduction-au-Filtrage-d’images-avec-Op</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://magic-nikos.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="https://magic-nikos.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://magic-nikos.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Opérations arithmétiques et logiques</title>
    <link href="https://magic-nikos.github.io/2024/03/01/Operations-arithmetiques-et-logiques/"/>
    <id>https://magic-nikos.github.io/2024/03/01/Operations-arithmetiques-et-logiques/</id>
    <published>2024-03-01T14:24:21.000Z</published>
    <updated>2024-03-01T14:24:37.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Article-educatif-Les-Operations-arithmetiques-et-logiques-en-OpenCV"><a href="#Article-educatif-Les-Operations-arithmetiques-et-logiques-en-OpenCV" class="headerlink" title="Article éducatif : Les Opérations arithmétiques et logiques en OpenCV"></a>Article éducatif : Les Opérations arithmétiques et logiques en OpenCV</h1><p>Bonjour chers lecteurs ! Aujourd’hui, nous allons plonger dans le monde fascinant des opérations arithmétiques et logiques en OpenCV. Ces opérations sont essentielles pour manipuler et traiter efficacement des images. Dans cet article, nous allons découvrir ce que sont ces opérations, comment les utiliser, et quelles applications pratiques elles peuvent avoir. </p><h2 id="Introduction-aux-Operations-arithmetiques-et-logiques"><a href="#Introduction-aux-Operations-arithmetiques-et-logiques" class="headerlink" title="Introduction aux Opérations arithmétiques et logiques"></a>Introduction aux Opérations arithmétiques et logiques</h2><p>Les opérations arithmétiques et logiques en OpenCV permettent de réaliser des calculs simples ou complexes sur des images. Ces opérations permettent de modifier la luminosité, le contraste, fusionner des images, ou encore effectuer des opérations booléennes. Elles sont indispensables dans le traitement d’images pour effectuer des transformations et des filtrages.</p><h2 id="Operations-arithmetiques"><a href="#Operations-arithmetiques" class="headerlink" title="Opérations arithmétiques"></a>Opérations arithmétiques</h2><p>Les opérations arithmétiques de base sont l’addition et la soustraction d’images. Voici un exemple simple en OpenCV :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Charger deux images</span></span><br><span class="line">image1 = cv2.imread(<span class="string">&#x27;image1.jpg&#x27;</span>)</span><br><span class="line">image2 = cv2.imread(<span class="string">&#x27;image2.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Addition des deux images</span></span><br><span class="line">result = cv2.add(image1, image2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Afficher le résultat</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;Résultat&#x27;</span>, result)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>Cette opération va ajouter les valeurs des pixels de chaque image pour produire une nouvelle image résultante.</p><h2 id="Operations-logiques"><a href="#Operations-logiques" class="headerlink" title="Opérations logiques"></a>Opérations logiques</h2><p>Les opérations logiques les plus courantes sont l’ET logique, l’OU logique et le NON logique. Elles sont souvent utilisées pour combiner différentes masques binaires. Voici un exemple pour illustrer l’opération logique ET :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Charger une image</span></span><br><span class="line">image = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convertir l&#x27;image en niveaux de gris</span></span><br><span class="line">gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Appliquer un seuillage</span></span><br><span class="line">_, threshold = cv2.threshold(gray_image, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Opération logique ET avec un masque</span></span><br><span class="line">result = cv2.bitwise_and(image, image, mask=threshold)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Afficher le résultat</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;Résultat&#x27;</span>, result)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>Cette opération va appliquer le masque binaire sur l’image d’origine, ne conservant que les pixels où le masque est blanc.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>En conclusion, les opérations arithmétiques et logiques en OpenCV sont des outils puissants pour manipuler des images de manière précise et efficace. Que ce soit pour corriger des défauts, améliorer la qualité des images, ou segmenter des éléments spécifiques, ces opérations offrent de nombreuses possibilités d’application. En les maîtrisant, vous serez en mesure de réaliser des traitements avancés sur vos images en toute simplicité.</p><p>N’hésitez pas à explorer davantage ces opérations et à les intégrer dans vos projets pour des résultats impressionnants !</p><hr><p>J’espère que cet article vous a permis de mieux appréhender les opérations arithmétiques et logiques en OpenCV. N’hésitez pas à partager vos retours et à poser vos questions dans les commentaires. Merci de votre lecture et à bientôt pour de nouvelles explorations dans le monde passionnant de la vision par ordinateur !</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Article-educatif-Les-Operations-arithmetiques-et-logiques-en-OpenCV&quot;&gt;&lt;a href=&quot;#Article-educatif-Les-Operations-arithmetiques-et-logi</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://magic-nikos.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="https://magic-nikos.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://magic-nikos.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Traitement d&#39;images</title>
    <link href="https://magic-nikos.github.io/2024/03/01/Traitement-d-images/"/>
    <id>https://magic-nikos.github.io/2024/03/01/Traitement-d-images/</id>
    <published>2024-03-01T14:24:06.000Z</published>
    <updated>2024-03-01T14:24:19.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Article-educatif-OpenCV-Traitement-d’images"><a href="#Article-educatif-OpenCV-Traitement-d’images" class="headerlink" title="Article éducatif : OpenCV - Traitement d’images"></a>Article éducatif : OpenCV - Traitement d’images</h1><p>Bienvenue dans ce guide dédié aux débutants en OpenCV ! Aujourd’hui, nous allons plonger dans le fascinant monde du traitement d’images en utilisant OpenCV. Que vous soyez un étudiant curieux ou un développeur en herbe, ce tutoriel vous fournira les bases nécessaires pour comprendre et maîtriser le traitement d’images.</p><h2 id="Introduction-au-traitement-d’images"><a href="#Introduction-au-traitement-d’images" class="headerlink" title="Introduction au traitement d’images"></a>Introduction au traitement d’images</h2><p>Le traitement d’images est un domaine de l’informatique qui consiste à effectuer des opérations sur des images numériques afin de les améliorer, les analyser ou en extraire des informations. Avec OpenCV, une puissante bibliothèque open-source dédiée à la vision par ordinateur, vous pouvez réaliser toutes sortes de transformations sur des images.</p><h2 id="Les-concepts-de-base"><a href="#Les-concepts-de-base" class="headerlink" title="Les concepts de base"></a>Les concepts de base</h2><h3 id="Chargement-d’une-image"><a href="#Chargement-d’une-image" class="headerlink" title="Chargement d’une image"></a>Chargement d’une image</h3><p>Pour commencer, chargeons une image à partir d’un fichier et affichons-la à l’écran :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">image = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;Image&#x27;</span>, image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="Conversion-en-niveaux-de-gris"><a href="#Conversion-en-niveaux-de-gris" class="headerlink" title="Conversion en niveaux de gris"></a>Conversion en niveaux de gris</h3><p>Il est souvent utile de convertir une image en niveaux de gris pour simplifier le traitement. Voici comment le faire avec OpenCV :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;Gray Image&#x27;</span>, gray_image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="Application-de-filtres"><a href="#Application-de-filtres" class="headerlink" title="Application de filtres"></a>Application de filtres</h3><p>Les filtres permettent d’effectuer des transformations sur une image, comme le lissage ou la détection de contours. Voici un exemple de l’application d’un filtre de flou :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blurred_image = cv2.GaussianBlur(image, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;Blurred Image&#x27;</span>, blurred_image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>En conclusion, le traitement d’images avec OpenCV offre un potentiel immense dans de nombreux domaines tels que la reconnaissance faciale, la détection d’objets, la réalité augmentée, etc. En comprenant les bases du traitement d’images, vous pourrez explorer ces applications passionnantes et développer des projets innovants.</p><p>N’oubliez pas de pratiquer régulièrement et d’explorer davantage les fonctionnalités d’OpenCV pour approfondir vos connaissances en traitement d’images. Bonne découverte !</p><hr><p>Pour plus d’informations sur OpenCV, consultez la <a href="https://docs.opencv.org/">documentation officielle</a>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Article-educatif-OpenCV-Traitement-d’images&quot;&gt;&lt;a href=&quot;#Article-educatif-OpenCV-Traitement-d’images&quot; class=&quot;headerlink&quot; title=&quot;Articl</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://magic-nikos.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="https://magic-nikos.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://magic-nikos.github.io/tags/opencv/"/>
    
  </entry>
  
</feed>
